# accounting-manager

## Description
A comprehensive accounting management skill for the AI Employee that maintains financial records, logs income and expenses, and generates weekly/monthly summaries. All accounting data is stored in the vault's Accounting folder.

## Parameters
- `action` (string, required): Action to perform - "log", "list", "summary", "weekly_report", "monthly_report"
- `transaction_type` (string, optional): Type of transaction - "income" or "expense"
- `amount` (number, optional): Amount in USD (positive number)
- `description` (string, optional): Description of the transaction
- `date` (string, optional): Date in YYYY-MM-DD format (default: today)
- `category` (string, optional): Category for the transaction (e.g., "sales", "services", "salary", "rent", "utilities")

## Functionality
When invoked, this skill enables the AI Employee to:

1. **Log Transactions**
   - Record income and expenses with date, type, amount, and description
   - Automatically maintain Current_Month.md file
   - Support categorization for better tracking

2. **View Transactions**
   - List all transactions for current month
   - Filter by type (income/expense)
   - Filter by date range

3. **Generate Summaries**
   - Calculate total income and expenses
   - Compute net profit/loss
   - Generate weekly and monthly reports
   - Provide category-wise breakdown

4. **File Management**
   - Maintain Current_Month.md in Accounting folder
   - Archive previous months automatically
   - Ensure data integrity with backup

## Constraints
- All amounts must be positive numbers
- Date format must be YYYY-MM-DD
- Transaction type must be "income" or "expense"
- All operations are logged to Accounting/logs/accounting.log
- File changes are backed up before modification

## File Structure

```
AI_Employee_Vault/
├── Accounting/
│   ├── Current_Month.md          # Current month's transactions
│   ├── 2026-02_February.md       # Archived months
│   ├── logs/
│   │   └── accounting.log        # Operation logs
│   └── backups/
│       └── Current_Month.md.backup  # Backup files
```

## Current_Month.md Format

```markdown
# Accounting Records - February 2026

**Month:** February  
**Year:** 2026  
**Last Updated:** 2026-02-18 14:30:00

---

## Transactions

| Date | Type | Category | Amount | Description |
|------|------|----------|--------|-------------|
| 2026-02-01 | income | sales | 5000.00 | Product sales - Week 1 |
| 2026-02-02 | expense | rent | 2000.00 | Office rent - February |
| 2026-02-05 | income | services | 1500.00 | Consulting services |
| 2026-02-10 | expense | utilities | 300.00 | Electricity bill |

---

## Summary

| Metric | Amount |
|--------|--------|
| Total Income | $6500.00 |
| Total Expenses | $2300.00 |
| Net Profit | $4200.00 |
| Profit Margin | 64.6% |

---

## Category Breakdown

### Income by Category
| Category | Amount | Percentage |
|----------|--------|------------|
| sales | $5000.00 | 76.9% |
| services | $1500.00 | 23.1% |

### Expenses by Category
| Category | Amount | Percentage |
|----------|--------|------------|
| rent | $2000.00 | 87.0% |
| utilities | $300.00 | 13.0% |

---

*Generated by accounting-manager skill*
```

## Implementation
```python
import os
import json
import shutil
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Dict, Optional
import re


class AccountingManager:
    """Manages accounting records for the AI Employee."""
    
    def __init__(self, vault_root: str = None):
        """Initialize accounting manager."""
        if vault_root is None:
            # Default to parent directory of scripts
            self.vault_root = Path(__file__).parent.parent
        else:
            self.vault_root = Path(vault_root)
        
        self.accounting_dir = self.vault_root / "Accounting"
        self.logs_dir = self.accounting_dir / "logs"
        self.backups_dir = self.accounting_dir / "backups"
        
        # Ensure directories exist
        self._ensure_directories()
        
        # Get current month file
        self.current_file = self._get_current_month_file()
    
    def _ensure_directories(self):
        """Ensure all required directories exist."""
        for directory in [self.accounting_dir, self.logs_dir, self.backups_dir]:
            directory.mkdir(parents=True, exist_ok=True)
    
    def _get_current_month_file(self) -> Path:
        """Get the path to current month's accounting file."""
        now = datetime.now()
        month_name = now.strftime("%B")
        filename = f"Current_Month.md"
        return self.accounting_dir / filename
    
    def _get_month_filename(self, date: datetime = None) -> str:
        """Generate filename for a given month."""
        if date is None:
            date = datetime.now()
        return date.strftime("%Y-%m_%B.md")
    
    def _create_backup(self, filepath: Path) -> Optional[Path]:
        """Create backup of a file."""
        if not filepath.exists():
            return None
        
        backup_name = f"{filepath.name}.backup"
        backup_path = self.backups_dir / backup_name
        
        # If backup exists, create timestamped version
        if backup_path.exists():
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"{filepath.name}.{timestamp}.backup"
            backup_path = self.backups_dir / backup_name
        
        try:
            shutil.copy2(filepath, backup_path)
            self._log_operation("backup_created", {"file": str(backup_path)})
            return backup_path
        except Exception as e:
            self._log_operation("backup_failed", {"error": str(e)}, "error")
            return None
    
    def _log_operation(self, operation: str, details: Dict = None, status: str = "success"):
        """Log an accounting operation."""
        log_file = self.logs_dir / "accounting.log"
        
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "operation": operation,
            "details": details or {},
            "status": status
        }
        
        try:
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write(json.dumps(log_entry) + "\n")
        except Exception as e:
            print(f"Failed to log operation: {str(e)}")
    
    def _parse_transactions(self, content: str) -> List[Dict]:
        """Parse transactions from markdown content."""
        transactions = []
        
        # Find table rows (skip header rows)
        in_table = False
        lines = content.split('\n')
        
        for line in lines:
            line = line.strip()
            
            # Detect table start
            if line.startswith('| Date |'):
                in_table = True
                continue
            
            # Detect table end
            if in_table and line.startswith('|---'):
                continue
            
            # Parse table row
            if in_table and line.startswith('|') and line.endswith('|'):
                # Skip separator row
                if '|---|' in line:
                    continue
                
                # Parse columns
                parts = line.split('|')
                parts = [p.strip() for p in parts if p.strip()]
                
                if len(parts) >= 5:
                    try:
                        transaction = {
                            "date": parts[0],
                            "type": parts[1],
                            "category": parts[2],
                            "amount": float(parts[3].replace('$', '').replace(',', '')),
                            "description": parts[4]
                        }
                        transactions.append(transaction)
                    except (ValueError, IndexError):
                        continue
            
            # Exit table on empty line or new section
            if in_table and (not line or line.startswith('---')):
                in_table = False
        
        return transactions
    
    def _generate_summary(self, transactions: List[Dict]) -> Dict:
        """Generate summary from transactions."""
        summary = {
            "total_income": 0.0,
            "total_expenses": 0.0,
            "net_profit": 0.0,
            "profit_margin": 0.0,
            "income_by_category": {},
            "expense_by_category": {}
        }
        
        for txn in transactions:
            amount = txn["amount"]
            txn_type = txn["type"].lower()
            category = txn.get("category", "uncategorized")
            
            if txn_type == "income":
                summary["total_income"] += amount
                summary["income_by_category"][category] = \
                    summary["income_by_category"].get(category, 0.0) + amount
            elif txn_type == "expense":
                summary["total_expenses"] += amount
                summary["expense_by_category"][category] = \
                    summary["expense_by_category"].get(category, 0.0) + amount
        
        # Calculate net profit and margin
        summary["net_profit"] = summary["total_income"] - summary["total_expenses"]
        if summary["total_income"] > 0:
            summary["profit_margin"] = (summary["net_profit"] / summary["total_income"]) * 100
        
        return summary
    
    def _generate_markdown(self, transactions: List[Dict], summary: Dict = None) -> str:
        """Generate markdown content for accounting file."""
        now = datetime.now()
        month_name = now.strftime("%B")
        year = now.year
        
        content = f"""# Accounting Records - {month_name} {year}

**Month:** {month_name}  
**Year:** {year}  
**Last Updated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

---

## Transactions

| Date | Type | Category | Amount | Description |
|------|------|----------|--------|-------------|
"""
        
        # Add transactions
        for txn in sorted(transactions, key=lambda x: x["date"], reverse=True):
            content += f"| {txn['date']} | {txn['type']} | {txn.get('category', 'general')} | ${txn['amount']:,.2f} | {txn['description']} |\n"
        
        # Generate and add summary
        if summary is None:
            summary = self._generate_summary(transactions)
        
        content += f"""
---

## Summary

| Metric | Amount |
|--------|--------|
| Total Income | ${summary['total_income']:,.2f} |
| Total Expenses | ${summary['total_expenses']:,.2f} |
| Net Profit | ${summary['net_profit']:,.2f} |
| Profit Margin | {summary['profit_margin']:.1f}% |

---

## Category Breakdown

### Income by Category
| Category | Amount | Percentage |
|----------|--------|------------|
"""
        
        # Income categories
        if summary["income_by_category"]:
            for category, amount in sorted(summary["income_by_category"].items(), key=lambda x: x[1], reverse=True):
                percentage = (amount / summary["total_income"] * 100) if summary["total_income"] > 0 else 0
                content += f"| {category} | ${amount:,.2f} | {percentage:.1f}% |\n"
        else:
            content += "| No income recorded | - | - |\n"
        
        content += """
### Expenses by Category
| Category | Amount | Percentage |
|----------|--------|------------|
"""
        
        # Expense categories
        if summary["expense_by_category"]:
            for category, amount in sorted(summary["expense_by_category"].items(), key=lambda x: x[1], reverse=True):
                percentage = (amount / summary["total_expenses"] * 100) if summary["total_expenses"] > 0 else 0
                content += f"| {category} | ${amount:,.2f} | {percentage:.1f}% |\n"
        else:
            content += "| No expenses recorded | - | - |\n"
        
        content += "\n---\n\n*Generated by accounting-manager skill*\n"
        
        return content
    
    def log_transaction(self, transaction_type: str, amount: float, 
                       description: str, date: str = None, 
                       category: str = "general") -> Dict:
        """
        Log a new transaction.
        
        Args:
            transaction_type: "income" or "expense"
            amount: Amount (positive number)
            description: Transaction description
            date: Date in YYYY-MM-DD format (default: today)
            category: Category (default: "general")
        
        Returns:
            Dict with status and transaction details
        """
        result = {
            "success": False,
            "message": "",
            "transaction": None
        }
        
        # Validate transaction type
        if transaction_type.lower() not in ["income", "expense"]:
            result["message"] = "Invalid transaction type. Must be 'income' or 'expense'."
            return result
        
        # Validate amount
        if amount <= 0:
            result["message"] = "Amount must be a positive number."
            return result
        
        # Set date
        if date is None:
            date = datetime.now().strftime("%Y-%m-%d")
        else:
            # Validate date format
            try:
                datetime.strptime(date, "%Y-%m-%d")
            except ValueError:
                result["message"] = "Invalid date format. Use YYYY-MM-DD."
                return result
        
        # Create backup
        if self.current_file.exists():
            self._create_backup(self.current_file)
        
        # Read existing transactions
        transactions = []
        if self.current_file.exists():
            try:
                with open(self.current_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    transactions = self._parse_transactions(content)
            except Exception as e:
                self._log_operation("read_error", {"error": str(e)}, "error")
        
        # Add new transaction
        transaction = {
            "date": date,
            "type": transaction_type.lower(),
            "category": category,
            "amount": amount,
            "description": description
        }
        transactions.append(transaction)
        
        # Generate new content
        summary = self._generate_summary(transactions)
        content = self._generate_markdown(transactions, summary)
        
        # Write file
        try:
            with open(self.current_file, 'w', encoding='utf-8') as f:
                f.write(content)
            
            result["success"] = True
            result["message"] = f"Transaction logged: {transaction_type} ${amount:,.2f}"
            result["transaction"] = transaction
            
            self._log_operation("transaction_logged", {
                "type": transaction_type,
                "amount": amount,
                "date": date,
                "category": category
            })
            
        except Exception as e:
            result["message"] = f"Failed to write file: {str(e)}"
            self._log_operation("write_error", {"error": str(e)}, "error")
        
        return result
    
    def list_transactions(self, transaction_type: str = None, 
                         start_date: str = None, 
                         end_date: str = None) -> List[Dict]:
        """
        List transactions with optional filters.
        
        Args:
            transaction_type: Filter by "income" or "expense"
            start_date: Filter from date (YYYY-MM-DD)
            end_date: Filter to date (YYYY-MM-DD)
        
        Returns:
            List of transactions
        """
        if not self.current_file.exists():
            return []
        
        try:
            with open(self.current_file, 'r', encoding='utf-8') as f:
                content = f.read()
                transactions = self._parse_transactions(content)
        except Exception as e:
            self._log_operation("read_error", {"error": str(e)}, "error")
            return []
        
        # Apply filters
        filtered = []
        for txn in transactions:
            # Filter by type
            if transaction_type and txn["type"].lower() != transaction_type.lower():
                continue
            
            # Filter by date range
            if start_date and txn["date"] < start_date:
                continue
            if end_date and txn["date"] > end_date:
                continue
            
            filtered.append(txn)
        
        self._log_operation("transactions_listed", {
            "count": len(filtered),
            "filters": {
                "type": transaction_type,
                "start_date": start_date,
                "end_date": end_date
            }
        })
        
        return filtered
    
    def get_summary(self) -> Dict:
        """
        Get current month's summary.
        
        Returns:
            Dict with summary statistics
        """
        transactions = self.list_transactions()
        summary = self._generate_summary(transactions)
        
        # Add metadata
        summary["transaction_count"] = len(transactions)
        summary["income_count"] = len([t for t in transactions if t["type"] == "income"])
        summary["expense_count"] = len([t for t in transactions if t["type"] == "expense"])
        summary["period"] = datetime.now().strftime("%B %Y")
        
        self._log_operation("summary_generated", summary)
        
        return summary
    
    def get_weekly_report(self, week_offset: int = 0) -> Dict:
        """
        Generate weekly report.
        
        Args:
            week_offset: Weeks from current week (0 = this week, -1 = last week)
        
        Returns:
            Dict with weekly summary
        """
        now = datetime.now()
        
        # Calculate week boundaries
        # Week starts on Monday
        days_since_monday = now.weekday()
        start_of_week = now - timedelta(days=days_since_monday)
        
        # Adjust for offset
        start_of_week = start_of_week + timedelta(weeks=week_offset)
        end_of_week = start_of_week + timedelta(days=6)
        
        start_date = start_of_week.strftime("%Y-%m-%d")
        end_date = end_of_week.strftime("%Y-%m-%d")
        
        # Get transactions for the week
        transactions = self.list_transactions(start_date=start_date, end_date=end_date)
        summary = self._generate_summary(transactions)
        
        # Add metadata
        summary["week_start"] = start_date
        summary["week_end"] = end_date
        summary["transaction_count"] = len(transactions)
        summary["week_number"] = start_of_week.isocalendar()[1]
        
        self._log_operation("weekly_report_generated", summary)
        
        return summary
    
    def get_monthly_report(self, month: int = None, year: int = None) -> Dict:
        """
        Generate monthly report.
        
        Args:
            month: Month number (1-12), default: current month
            year: Year, default: current year
        
        Returns:
            Dict with monthly summary
        """
        if month is None:
            month = datetime.now().month
        if year is None:
            year = datetime.now().year
        
        # For current month, use existing method
        if month == datetime.now().month and year == datetime.now().year:
            summary = self.get_summary()
            summary["month"] = month
            summary["year"] = year
            return summary
        
        # For other months, would need to read archived file
        # This is a simplified implementation
        return {
            "month": month,
            "year": year,
            "note": "Historical month reports require archived file access"
        }


# ============================================================================
# Skill Entry Point
# ============================================================================

def accounting_manager_skill(action: str, **kwargs) -> Dict:
    """
    Main entry point for the accounting-manager skill.
    
    Args:
        action: Action to perform
        **kwargs: Action-specific parameters
    
    Returns:
        Result dictionary
    """
    manager = AccountingManager()
    
    if action == "log":
        return manager.log_transaction(
            transaction_type=kwargs.get("transaction_type", ""),
            amount=kwargs.get("amount", 0),
            description=kwargs.get("description", ""),
            date=kwargs.get("date"),
            category=kwargs.get("category", "general")
        )
    
    elif action == "list":
        transactions = manager.list_transactions(
            transaction_type=kwargs.get("transaction_type"),
            start_date=kwargs.get("start_date"),
            end_date=kwargs.get("end_date")
        )
        return {
            "success": True,
            "count": len(transactions),
            "transactions": transactions
        }
    
    elif action == "summary":
        summary = manager.get_summary()
        return {
            "success": True,
            "summary": summary
        }
    
    elif action == "weekly_report":
        report = manager.get_weekly_report(
            week_offset=kwargs.get("week_offset", 0)
        )
        return {
            "success": True,
            "report": report
        }
    
    elif action == "monthly_report":
        report = manager.get_monthly_report(
            month=kwargs.get("month"),
            year=kwargs.get("year")
        )
        return {
            "success": True,
            "report": report
        }
    
    else:
        return {
            "success": False,
            "message": f"Unknown action: {action}. Valid actions: log, list, summary, weekly_report, monthly_report"
        }


# Example usage
if __name__ == "__main__":
    # Log a transaction
    result = accounting_manager_skill(
        action="log",
        transaction_type="income",
        amount=5000.00,
        description="Product sales - Week 1",
        category="sales"
    )
    print(json.dumps(result, indent=2))
    
    # Get summary
    result = accounting_manager_skill(action="summary")
    print(json.dumps(result, indent=2))
```

## Usage Examples

### Log Income
```python
accounting_manager_skill(
    action="log",
    transaction_type="income",
    amount=5000.00,
    description="Product sales",
    category="sales"
)
```

### Log Expense
```python
accounting_manager_skill(
    action="log",
    transaction_type="expense",
    amount=2000.00,
    description="Office rent",
    category="rent"
)
```

### Get Summary
```python
result = accounting_manager_skill(action="summary")
```

### Get Weekly Report
```python
result = accounting_manager_skill(
    action="weekly_report",
    week_offset=0  # 0 = this week, -1 = last week
)
```

### List Transactions
```python
result = accounting_manager_skill(
    action="list",
    transaction_type="income"  # Optional filter
)
```

## Claude Integration

Once this skill is installed in `.claude/skills/accounting-manager/`, Claude can:

1. **Track all business transactions**
2. **Maintain accurate financial records**
3. **Generate reports on demand**
4. **Answer questions about income/expenses**
5. **Provide financial insights**

## Testing

```bash
# Run the script directly to test
python scripts/accounting_manager.py

# Test specific functions
python -c "
from scripts.accounting_manager import AccountingManager
mgr = AccountingManager()
print(mgr.log_transaction('income', 1000, 'Test income'))
print(mgr.get_summary())
"
```

## Best Practices

1. **Log transactions immediately** - Don't wait to record transactions
2. **Use categories consistently** - Makes reporting more useful
3. **Review weekly summaries** - Stay on top of finances
4. **Backup regularly** - Backups are automatic, but verify periodically
5. **Archive monthly** - Previous months are automatically archived

## Troubleshooting

**File not found:**
- Ensure Accounting folder exists
- Check permissions on vault directory

**Invalid format:**
- Use YYYY-MM-DD for dates
- Amounts must be positive numbers
- Transaction type must be "income" or "expense"

**Data loss:**
- Check backups folder for previous versions
- Review accounting.log for error details
