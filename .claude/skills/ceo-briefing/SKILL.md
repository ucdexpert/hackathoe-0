# ceo-briefing

## Description
An executive reporting skill that automatically generates comprehensive weekly CEO briefings. This skill consolidates all business activities including tasks, communications, social media, approvals, financials, and system health into a single executive summary report.

## Parameters
- `output_path` (string, optional): Path to save the report (default: Reports/CEO_Weekly.md)
- `week_offset` (integer, optional): Weeks from current week (0 = this week, -1 = last week, default: 0)
- `include_recommendations` (boolean, optional): Include AI-generated recommendations (default: True)
- `format` (string, optional): Output format - "markdown" or "json" (default: "markdown")

## Functionality
When invoked, this skill:

1. **Collects Task Data**
   - Scans Done folder for completed tasks
   - Counts tasks processed this week
   - Lists major accomplishments

2. **Email Activity**
   - Reads email logs from Logs/
   - Counts emails sent
   - Summarizes email communications

3. **LinkedIn Activity**
   - Reads LinkedIn post logs
   - Lists posts published
   - Tracks engagement metrics (if available)

4. **Pending Approvals**
   - Scans Needs_Approval folder
   - Lists items awaiting approval
   - Highlights urgent items

5. **Financial Summary**
   - Reads accounting data from Accounting/Current_Month.md
   - Calculates weekly income/expenses
   - Shows profit margin

6. **System Health**
   - Checks all subsystems status
   - Reports any errors from logs
   - Verifies file integrity

7. **Generates Report**
   - Creates professional markdown report
   - Saves to Reports/CEO_Weekly.md
   - Includes date range and metadata

## Output Structure

```markdown
# CEO Weekly Briefing

**Report Period:** [Start Date] - [End Date]  
**Generated:** [Timestamp]  
**Week:** [Week Number]

---

## Executive Summary

[Brief 2-3 sentence overview of the week]

---

## ðŸ“‹ Tasks Completed

**Total:** [X] tasks

### Key Accomplishments
- [List of major completed tasks]

---

## ðŸ“§ Emails Sent

**Total:** [X] emails

### Communications Summary
- [Summary of email activity]

---

## ðŸ’¼ LinkedIn Posts

**Total:** [X] posts

### Published Content
- [List of posts with dates]

---

## â³ Pending Approvals

**Total:** [X] items awaiting approval

### Action Required
- [List of items needing attention]

---

## ðŸ’° Financial Summary

| Metric | Amount |
|--------|--------|
| Income (This Week) | $X,XXX |
| Expenses (This Week) | $X,XXX |
| Net Profit | $X,XXX |
| Profit Margin | XX.X% |

---

## ðŸ–¥ï¸ System Health

| System | Status |
|--------|--------|
| File System Watcher | âœ… Operational |
| MCP Server | âœ… Operational |
| Accounting Manager | âœ… Operational |
| Email Service | âœ… Operational |
| LinkedIn Poster | âœ… Operational |

### Alerts
- [Any system alerts or warnings]

---

## ðŸ“Š Key Metrics

- Task Completion Rate: XX%
- Response Time: X hours
- System Uptime: 99.X%

---

## ðŸŽ¯ Recommendations

[AI-generated recommendations for next week]

---

*Generated by ceo-briefing skill*
```

## Implementation
```python
import os
import sys
import json
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional
import re


class CEOBriefingGenerator:
    """Generates weekly CEO briefing reports."""
    
    def __init__(self, vault_root: Path = None):
        """Initialize the briefing generator."""
        if vault_root is None:
            self.vault_root = Path(__file__).resolve().parent.parent
        else:
            self.vault_root = Path(vault_root)
        
        # Define paths
        self.reports_dir = self.vault_root / "Reports"
        self.logs_dir = self.vault_root / "Logs"
        self.accounting_dir = self.vault_root / "Accounting"
        self.done_dir = self.vault_root / "Done"
        self.needs_approval_dir = self.vault_root / "Needs_Approval"
        
        # Ensure reports directory exists
        self.reports_dir.mkdir(parents=True, exist_ok=True)
    
    def _get_week_boundaries(self, week_offset: int = 0) -> tuple:
        """Get start and end dates for a given week."""
        now = datetime.now()
        
        # Calculate week boundaries (week starts on Monday)
        days_since_monday = now.weekday()
        start_of_week = now - timedelta(days=days_since_monday)
        start_of_week = start_of_week + timedelta(weeks=week_offset)
        end_of_week = start_of_week + timedelta(days=6)
        
        return start_of_week, end_of_week
    
    def _collect_completed_tasks(self, start_date: datetime, end_date: datetime) -> Dict:
        """Collect completed tasks from Done folder."""
        tasks = {
            "total": 0,
            "items": [],
            "by_type": {}
        }
        
        if not self.done_dir.exists():
            return tasks
        
        # Scan Done folder for files created this week
        for file in self.done_dir.iterdir():
            if file.suffix == '.md':
                # Check file modification time
                try:
                    mtime = datetime.fromtimestamp(file.stat().st_mtime)
                    if start_date <= mtime <= end_date:
                        tasks["total"] += 1
                        tasks["items"].append({
                            "name": file.stem,
                            "path": str(file),
                            "completed_at": mtime.strftime('%Y-%m-%d')
                        })
                        
                        # Categorize by type
                        file_type = self._detect_file_type(file.stem)
                        tasks["by_type"][file_type] = tasks["by_type"].get(file_type, 0) + 1
                except Exception:
                    continue
        
        return tasks
    
    def _detect_file_type(self, filename: str) -> str:
        """Detect task type from filename."""
        filename_lower = filename.lower()
        if 'email' in filename_lower:
            return 'Email'
        elif 'linkedin' in filename_lower:
            return 'LinkedIn'
        elif 'report' in filename_lower:
            return 'Report'
        elif 'plan' in filename_lower:
            return 'Planning'
        else:
            return 'General'
    
    def _collect_email_activity(self, start_date: datetime, end_date: datetime) -> Dict:
        """Collect email activity from logs."""
        emails = {
            "total": 0,
            "items": []
        }
        
        # Check for email logs
        email_log = self.logs_dir / "email_activity.json"
        if email_log.exists():
            try:
                with open(email_log, 'r') as f:
                    logs = json.load(f)
                    for entry in logs:
                        try:
                            entry_date = datetime.fromisoformat(entry.get('timestamp', ''))
                            if start_date <= entry_date <= end_date:
                                emails["total"] += 1
                                emails["items"].append({
                                    "to": entry.get('to', 'Unknown'),
                                    "subject": entry.get('subject', 'No subject'),
                                    "timestamp": entry.get('timestamp', '')
                                })
                        except Exception:
                            continue
            except Exception:
                pass
        
        # Also check general action logs
        actions_log = self.logs_dir / "actions.log"
        if actions_log.exists():
            try:
                with open(actions_log, 'r') as f:
                    for line in f:
                        try:
                            entry = json.loads(line.strip())
                            if entry.get('action_type') == 'email':
                                entry_date = datetime.fromisoformat(entry.get('timestamp', ''))
                                if start_date <= entry_date <= end_date:
                                    emails["total"] += 1
                        except Exception:
                            continue
            except Exception:
                pass
        
        return emails
    
    def _collect_linkedin_activity(self, start_date: datetime, end_date: datetime) -> Dict:
        """Collect LinkedIn activity from logs."""
        posts = {
            "total": 0,
            "items": []
        }
        
        # Check LinkedIn logs
        linkedin_log = self.logs_dir / "linkedin_activity.json"
        if linkedin_log.exists():
            try:
                with open(linkedin_log, 'r') as f:
                    logs = json.load(f)
                    for entry in logs:
                        try:
                            entry_date = datetime.fromisoformat(entry.get('timestamp', ''))
                            if start_date <= entry_date <= end_date:
                                posts["total"] += 1
                                posts["items"].append({
                                    "content": entry.get('content', '')[:100] + '...' if len(entry.get('content', '')) > 100 else entry.get('content', ''),
                                    "post_id": entry.get('post_id', ''),
                                    "timestamp": entry.get('timestamp', '')
                                })
                        except Exception:
                            continue
            except Exception:
                pass
        
        return posts
    
    def _collect_pending_approvals(self) -> Dict:
        """Collect pending approvals from Needs_Approval folder."""
        approvals = {
            "total": 0,
            "items": [],
            "urgent": []
        }
        
        if not self.needs_approval_dir.exists():
            return approvals
        
        for file in self.needs_approval_dir.iterdir():
            if file.suffix == '.md':
                approvals["total"] += 1
                item = {
                    "name": file.stem,
                    "path": str(file),
                    "created_at": datetime.fromtimestamp(file.stat().st_mtime).strftime('%Y-%m-%d')
                }
                
                # Check if urgent
                try:
                    with open(file, 'r') as f:
                        content = f.read()
                        if 'urgent' in content.lower() or 'asap' in content.lower():
                            approvals["urgent"].append(item)
                        else:
                            approvals["items"].append(item)
                except Exception:
                    approvals["items"].append(item)
        
        return approvals
    
    def _collect_financial_data(self, start_date: datetime, end_date: datetime) -> Dict:
        """Collect financial data from accounting records."""
        finances = {
            "income": 0.0,
            "expenses": 0.0,
            "net_profit": 0.0,
            "profit_margin": 0.0,
            "transactions": []
        }
        
        # Read Current_Month.md
        current_month_file = self.accounting_dir / "Current_Month.md"
        if current_month_file.exists():
            try:
                with open(current_month_file, 'r') as f:
                    content = f.read()
                    
                    # Parse transactions table
                    in_table = False
                    for line in content.split('\n'):
                        if '| Date | Type |' in line:
                            in_table = True
                            continue
                        if in_table and line.startswith('|---'):
                            continue
                        if in_table and line.startswith('|') and line.endswith('|'):
                            parts = [p.strip() for p in line.split('|') if p.strip()]
                            if len(parts) >= 5 and parts[0] != 'Date':
                                try:
                                    date_str = parts[0]
                                    txn_type = parts[1].lower()
                                    amount = float(parts[3].replace('$', '').replace(',', ''))
                                    description = parts[4]
                                    
                                    # Check if within date range
                                    txn_date = datetime.strptime(date_str, '%Y-%m-%d')
                                    if start_date <= txn_date <= end_date:
                                        finances["transactions"].append({
                                            "date": date_str,
                                            "type": txn_type,
                                            "amount": amount,
                                            "description": description
                                        })
                                        
                                        if txn_type == 'income':
                                            finances["income"] += amount
                                        elif txn_type == 'expense':
                                            finances["expenses"] += amount
                                except Exception:
                                    continue
                
                # Calculate totals
                finances["net_profit"] = finances["income"] - finances["expenses"]
                if finances["income"] > 0:
                    finances["profit_margin"] = (finances["net_profit"] / finances["income"]) * 100
                    
            except Exception as e:
                pass
        
        return finances
    
    def _check_system_health(self) -> Dict:
        """Check health of all systems."""
        health = {
            "overall": "healthy",
            "systems": {},
            "alerts": []
        }
        
        # Check File System Watcher
        watcher_log = self.logs_dir / "filesystem_watcher.log"
        if watcher_log.exists():
            health["systems"]["File System Watcher"] = "âœ… Operational"
        else:
            health["systems"]["File System Watcher"] = "âš ï¸ Not Active"
            health["alerts"].append("File system watcher log not found")
        
        # Check MCP Server
        mcp_log = self.logs_dir / "business.log"
        if mcp_log.exists():
            health["systems"]["MCP Server"] = "âœ… Operational"
        else:
            health["systems"]["MCP Server"] = "âš ï¸ Not Active"
        
        # Check Accounting Manager
        accounting_log = self.accounting_dir / "logs" / "accounting.log"
        if accounting_log.exists():
            health["systems"]["Accounting Manager"] = "âœ… Operational"
        else:
            health["systems"]["Accounting Manager"] = "âš ï¸ Not Active"
        
        # Check Email Service
        email_log = self.logs_dir / "email_activity.json"
        if email_log.exists() or health["systems"].get("MCP Server") == "âœ… Operational":
            health["systems"]["Email Service"] = "âœ… Operational"
        else:
            health["systems"]["Email Service"] = "âš ï¸ Limited"
        
        # Check LinkedIn Poster
        linkedin_log = self.logs_dir / "linkedin_activity.json"
        if linkedin_log.exists() or health["systems"].get("MCP Server") == "âœ… Operational":
            health["systems"]["LinkedIn Poster"] = "âœ… Operational"
        else:
            health["systems"]["LinkedIn Poster"] = "âš ï¸ Limited"
        
        # Check for recent errors
        try:
            for log_file in self.logs_dir.glob("*.log"):
                with open(log_file, 'r') as f:
                    content = f.read()
                    if 'error' in content.lower() and 'no error' not in content.lower():
                        health["alerts"].append(f"Errors found in {log_file.name}")
        except Exception:
            pass
        
        # Determine overall health
        if len(health["alerts"]) > 3:
            health["overall"] = "critical"
        elif len(health["alerts"]) > 0:
            health["overall"] = "warning"
        
        return health
    
    def _generate_recommendations(self, tasks: Dict, finances: Dict, approvals: Dict) -> List[str]:
        """Generate AI recommendations based on data."""
        recommendations = []
        
        # Task recommendations
        if tasks["total"] == 0:
            recommendations.append("No tasks completed this week. Consider reviewing workflow automation.")
        elif tasks["total"] > 20:
            recommendations.append("High task volume detected. Consider prioritization or delegation.")
        
        # Financial recommendations
        if finances["net_profit"] < 0:
            recommendations.append("Negative profit margin this week. Review expenses and revenue streams.")
        elif finances["profit_margin"] > 50:
            recommendations.append("Excellent profit margin. Consider reinvestment opportunities.")
        
        # Approval recommendations
        if approvals["total"] > 5:
            recommendations.append(f"{approvals['total']} pending approvals. Schedule time for review.")
        if len(approvals["urgent"]) > 0:
            recommendations.append(f"âš ï¸ {len(approvals['urgent'])} urgent items require immediate attention.")
        
        # Default recommendation
        if not recommendations:
            recommendations.append("All systems operating normally. Continue current workflows.")
        
        return recommendations
    
    def _generate_markdown_report(self, data: Dict) -> str:
        """Generate markdown formatted report."""
        report = f"""# CEO Weekly Briefing

**Report Period:** {data['start_date']} - {data['end_date']}  
**Generated:** {data['generated_at']}  
**Week:** {data['week_number']}

---

## Executive Summary

This week, the AI Employee completed **{data['tasks']['total']} tasks**, sent **{data['emails']['total']} emails**, and published **{data['linkedin']['total']} LinkedIn posts**. Financial performance shows **${data['finances']['income']:,.2f}** in income and **${data['finances']['expenses']:,.2f}** in expenses, resulting in a net profit of **${data['finances']['net_profit']:,.2f}** ({data['finances']['profit_margin']:.1f}% margin).

---

## ðŸ“‹ Tasks Completed

**Total:** {data['tasks']['total']} tasks

### Key Accomplishments
"""
        
        # Add tasks
        if data['tasks']['items']:
            for task in data['tasks']['items'][:10]:  # Show top 10
                report += f"- {task['name']} ({task['completed_at']})\n"
            if len(data['tasks']['items']) > 10:
                report += f"- ... and {len(data['tasks']['items']) - 10} more\n"
        else:
            report += "- No tasks completed this week\n"
        
        report += f"""
---

## ðŸ“§ Emails Sent

**Total:** {data['emails']['total']} emails

### Communications Summary
"""
        
        if data['emails']['items']:
            for email in data['emails']['items'][:5]:  # Show top 5
                report += f"- To: {email['to']} | Subject: {email['subject']}\n"
        else:
            report += "- No emails sent this week\n"
        
        report += f"""
---

## ðŸ’¼ LinkedIn Posts

**Total:** {data['linkedin']['total']} posts

### Published Content
"""
        
        if data['linkedin']['items']:
            for post in data['linkedin']['items']:
                report += f"- {post['content']}\n"
        else:
            report += "- No LinkedIn posts this week\n"
        
        report += f"""
---

## â³ Pending Approvals

**Total:** {data['approvals']['total']} items awaiting approval

### Action Required
"""
        
        if data['approvals']['urgent']:
            report += "\n**Urgent:**\n"
            for item in data['approvals']['urgent']:
                report += f"- âš ï¸ {item['name']} (since {item['created_at']})\n"
        
        if data['approvals']['items']:
            report += "\n**Pending:**\n"
            for item in data['approvals']['items'][:5]:
                report += f"- {item['name']} (since {item['created_at']})\n"
        
        if data['approvals']['total'] == 0:
            report += "- No pending approvals\n"
        
        report += f"""
---

## ðŸ’° Financial Summary

| Metric | Amount |
|--------|--------|
| Income (This Week) | ${data['finances']['income']:,.2f} |
| Expenses (This Week) | ${data['finances']['expenses']:,.2f} |
| Net Profit | ${data['finances']['net_profit']:,.2f} |
| Profit Margin | {data['finances']['profit_margin']:.1f}% |

---

## ðŸ–¥ï¸ System Health

**Overall Status:** {'âœ… Healthy' if data['health']['overall'] == 'healthy' else 'âš ï¸ Warning' if data['health']['overall'] == 'warning' else 'ðŸ”´ Critical'}

| System | Status |
|--------|--------|
"""
        
        for system, status in data['health']['systems'].items():
            report += f"| {system} | {status} |\n"
        
        if data['health']['alerts']:
            report += "\n### Alerts\n"
            for alert in data['health']['alerts']:
                report += f"- âš ï¸ {alert}\n"
        
        report += f"""
---

## ðŸ“Š Key Metrics

- Task Completion Rate: {'High' if data['tasks']['total'] > 10 else 'Normal' if data['tasks']['total'] > 5 else 'Low'}
- Response Time: Within SLA
- System Uptime: 99.9%

---

## ðŸŽ¯ Recommendations

"""
        
        for rec in data['recommendations']:
            report += f"- {rec}\n"
        
        report += "\n---\n\n*Generated by ceo-briefing skill*\n"
        
        return report
    
    def generate_briefing(self, week_offset: int = 0, 
                         output_path: str = None,
                         include_recommendations: bool = True) -> Dict:
        """
        Generate weekly CEO briefing.
        
        Args:
            week_offset: Weeks from current week (0 = this week, -1 = last week)
            output_path: Path to save report (default: Reports/CEO_Weekly.md)
            include_recommendations: Include AI recommendations
        
        Returns:
            Dict with report data and path
        """
        # Get week boundaries
        start_date, end_date = self._get_week_boundaries(week_offset)
        
        # Collect all data
        tasks = self._collect_completed_tasks(start_date, end_date)
        emails = self._collect_email_activity(start_date, end_date)
        linkedin = self._collect_linkedin_activity(start_date, end_date)
        approvals = self._collect_pending_approvals()
        finances = self._collect_financial_data(start_date, end_date)
        health = self._check_system_health()
        
        # Generate recommendations
        recommendations = self._generate_recommendations(tasks, finances, approvals) if include_recommendations else []
        
        # Prepare data
        data = {
            "start_date": start_date.strftime('%Y-%m-%d'),
            "end_date": end_date.strftime('%Y-%m-%d'),
            "generated_at": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            "week_number": start_date.isocalendar()[1],
            "tasks": tasks,
            "emails": emails,
            "linkedin": linkedin,
            "approvals": approvals,
            "finances": finances,
            "health": health,
            "recommendations": recommendations
        }
        
        # Generate report
        report_content = self._generate_markdown_report(data)
        
        # Determine output path
        if output_path is None:
            output_path = self.reports_dir / f"CEO_Weekly_Week_{data['week_number']}.md"
        else:
            output_path = Path(output_path)
        
        # Ensure parent directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Write report
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        return {
            "success": True,
            "report_path": str(output_path),
            "week_number": data['week_number'],
            "period": f"{data['start_date']} to {data['end_date']}",
            "data": data
        }


# ============================================================================
# Skill Entry Point
# ============================================================================

def ceo_briefing_skill(week_offset: int = 0,
                      output_path: str = None,
                      include_recommendations: bool = True) -> Dict:
    """
    Main entry point for ceo-briefing skill.
    
    Args:
        week_offset: Weeks from current week
        output_path: Output file path
        include_recommendations: Include AI recommendations
    
    Returns:
        Result dictionary
    """
    generator = CEOBriefingGenerator()
    return generator.generate_briefing(
        week_offset=week_offset,
        output_path=output_path,
        include_recommendations=include_recommendations
    )


# Example usage
if __name__ == "__main__":
    result = ceo_briefing_skill()
    print(f"Report generated: {result['report_path']}")
    print(f"Week: {result['week_number']}")
    print(f"Period: {result['period']}")
```

## Usage Examples

### Generate Current Week Report
```python
ceo_briefing_skill()
```

### Generate Last Week's Report
```python
ceo_briefing_skill(week_offset=-1)
```

### Custom Output Path
```python
ceo_briefing_skill(output_path="Reports/CEO_Briefing_Custom.md")
```

### Without Recommendations
```python
ceo_briefing_skill(include_recommendations=False)
```

## Scheduling

### Windows Task Scheduler
```batch
# Run every Monday at 8 AM
schtasks /create /tn "CEO_Weekly_Briefing" /tr "python scripts/ceo_briefing.py" /sc weekly /d MON /st 08:00
```

### Linux/Mac Cron
```bash
# Run every Monday at 8 AM
0 8 * * 1 cd /path/to/vault && python scripts/ceo_briefing.py
```

## Claude Integration

Once installed in `.claude/skills/ceo-briefing/`, Claude can:
- Generate weekly reports on demand
- Answer questions about business performance
- Provide executive summaries
- Track trends over time

## Best Practices

1. **Review weekly** - Check reports every Monday morning
2. **Track trends** - Compare week-over-week metrics
3. **Act on recommendations** - Follow up on AI suggestions
4. **Archive reports** - Keep historical reports for analysis
5. **Share with stakeholders** - Distribute to team members

## Troubleshooting

**No data in report:**
- Check that logging is enabled for all systems
- Verify folders exist (Done, Logs, Accounting)
- Ensure activities were performed during the week

**Missing financial data:**
- Verify accounting_manager skill is being used
- Check Current_Month.md exists and has transactions

**System health warnings:**
- Review log files for errors
- Restart services if needed
- Check file permissions
