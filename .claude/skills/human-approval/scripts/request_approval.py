#!/usr/bin/env python3
"""
Human Approval Skill - Human-in-the-loop for sensitive actions

Usage:
    python request_approval.py --action email --data '{"to":"user@example.com"}'
    python request_approval.py --request-id email_20260218_123456 --check
    python request_approval.py --action linkedin --data '{"content":"Post text"}' --timeout 30
"""

import os
import sys
import json
import argparse
import time
import uuid
import re
from datetime import datetime
from typing import Optional, Tuple


# Resolve vault paths
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
VAULT_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, '..', '..', '..'))

FOLDERS = {
    'Needs_Approval': os.path.join(VAULT_ROOT, 'Needs_Approval'),
    'Approved': os.path.join(VAULT_ROOT, 'Approved'),
    'Rejected': os.path.join(VAULT_ROOT, 'Rejected'),
    'Needs_Action': os.path.join(VAULT_ROOT, 'Needs_Action')
}

DEFAULT_TIMEOUT_MINUTES = 60
POLL_INTERVAL_SECONDS = 10


def ensure_folders():
    """Ensure all folders exist."""
    for path in FOLDERS.values():
        if not os.path.exists(path):
            os.makedirs(path, exist_ok=True)


def create_approval_request(action_type: str, action_data: dict, request_id: str = None) -> Tuple[str, str]:
    """
    Create an approval request file.
    
    Args:
        action_type: Type of action (email, linkedin, etc.)
        action_data: Action data as dict
        request_id: Optional request ID (auto-generated if not provided)
    
    Returns:
        Tuple of (request_id, file_path)
    """
    ensure_folders()
    
    # Generate request ID if not provided
    if not request_id:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_id = uuid.uuid4().hex[:8]
        request_id = f"{action_type}_{timestamp}_{unique_id}"
    
    # Create file content
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    action_json = json.dumps(action_data, indent=2, default=str)
    
    content = f"""# Approval Request

## Request ID
{request_id}

## Action Type
{action_type}

## Created
{timestamp}

## Action Details
```json
{action_json}
```

## Instructions
To **APPROVE**: Change status below to `APPROVED`
To **REJECT**: Change status below to `REJECTED`

## Status
<!-- AI Employee monitors this field -->
status: PENDING

## Reviewer Comments

---
*Generated by human-approval skill*
"""
    
    # Write file
    filename = f"{request_id}.md"
    filepath = os.path.join(FOLDERS['Needs_Approval'], filename)
    
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)
    
    return request_id, filepath


def check_approval_status(request_id: str) -> Tuple[str, Optional[str], Optional[str]]:
    """
    Check approval status from request file.
    
    Args:
        request_id: Request ID to check
    
    Returns:
        Tuple of (status, decided_at, comments)
    """
    needs_approval_dir = FOLDERS['Needs_Approval']
    if not os.path.exists(needs_approval_dir):
        return 'PENDING', None, None
    
    # Find the request file
    for filename in os.listdir(needs_approval_dir):
        if request_id in filename and filename.endswith('.md'):
            filepath = os.path.join(needs_approval_dir, filename)
            break
    else:
        # Check in Approved/Rejected folders
        for folder_name in ['Approved', 'Rejected']:
            folder = FOLDERS.get(folder_name)
            if folder and os.path.exists(folder):
                for filename in os.listdir(folder):
                    if request_id in filename and filename.endswith('.md'):
                        filepath = os.path.join(folder, filename)
                        break
                else:
                    continue
                break
        else:
            return 'NOT_FOUND', None, None
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Parse status
        status_match = re.search(r'status:\s*(\w+)', content, re.IGNORECASE)
        status = status_match.group(1).upper() if status_match else 'PENDING'
        
        # Parse decided timestamp if present
        decided_match = re.search(r'\*(APPROVED|REJECTED)\s+at\s+(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\*', content)
        decided_at = decided_match.group(2) if decided_match else None
        
        # Parse comments
        comments_match = re.search(r'## Reviewer Comments\s*\n(.*?)(?=---|\Z)', content, re.DOTALL)
        comments = comments_match.group(1).strip() if comments_match else None
        if comments and comments.startswith('<!--'):
            comments = None
        
        return status, decided_at, comments
        
    except Exception:
        return 'ERROR', None, None


def wait_for_approval(request_id: str, timeout_minutes: int = DEFAULT_TIMEOUT_MINUTES,
                      poll_interval: int = POLL_INTERVAL_SECONDS, verbose: bool = True) -> str:
    """
    Wait for approval decision.
    
    Args:
        request_id: Request ID to wait for
        timeout_minutes: Maximum wait time
        poll_interval: Polling interval in seconds
        verbose: Print status updates
    
    Returns:
        Final status: APPROVED, REJECTED, or TIMEOUT
    """
    start_time = time.time()
    timeout_seconds = timeout_minutes * 60
    
    if verbose:
        print(f"Waiting for approval (timeout: {timeout_minutes} min)...")
        print(f"Request ID: {request_id}")
        print("-" * 50)
    
    while time.time() - start_time < timeout_seconds:
        status, decided_at, comments = check_approval_status(request_id)
        
        if verbose and int(time.time() - start_time) % (poll_interval * 3) < poll_interval:
            remaining = (timeout_seconds - (time.time() - start_time)) / 60
            print(f"Status: {status} | Remaining: {remaining:.1f} min")
        
        if status == 'APPROVED':
            if verbose:
                print("-" * 50)
                print(f"✓ APPROVED at {decided_at or 'unknown time'}")
                if comments:
                    print(f"Comments: {comments}")
            finalize_request(request_id, 'APPROVED')
            return 'APPROVED'
        
        elif status == 'REJECTED':
            if verbose:
                print("-" * 50)
                print(f"✗ REJECTED at {decided_at or 'unknown time'}")
                if comments:
                    print(f"Comments: {comments}")
            finalize_request(request_id, 'REJECTED')
            return 'REJECTED'
        
        time.sleep(poll_interval)
    
    # Timeout
    if verbose:
        print("-" * 50)
        print(f"⏱ TIMEOUT after {timeout_minutes} minutes")
    finalize_request(request_id, 'TIMEOUT')
    return 'TIMEOUT'


def finalize_request(request_id: str, status: str) -> Optional[str]:
    """
    Finalize request by moving to appropriate folder.
    
    Args:
        request_id: Request ID
        status: Final status (APPROVED, REJECTED, TIMEOUT)
    
    Returns:
        New file path or None
    """
    needs_approval_dir = FOLDERS['Needs_Approval']
    
    # Find source file
    source_path = None
    for filename in os.listdir(needs_approval_dir):
        if request_id in filename and filename.endswith('.md'):
            source_path = os.path.join(needs_approval_dir, filename)
            break
    
    if not source_path or not os.path.exists(source_path):
        return None
    
    # Determine destination
    if status == 'APPROVED':
        dest_folder = FOLDERS['Approved']
        prefix = 'approved'
    elif status == 'REJECTED':
        dest_folder = FOLDERS['Rejected']
        prefix = 'rejected'
    else:  # TIMEOUT
        dest_folder = FOLDERS['Needs_Action']
        prefix = 'timeout'
    
    ensure_folders()
    
    # Build destination path
    filename = os.path.basename(source_path)
    new_filename = f"{prefix}_{filename}"
    dest_path = os.path.join(dest_folder, new_filename)
    
    # Handle existing file
    if os.path.exists(dest_path):
        base, ext = os.path.splitext(new_filename)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        new_filename = f"{base}_{timestamp}{ext}"
        dest_path = os.path.join(dest_folder, new_filename)
    
    try:
        # Read, add finalization note, write
        with open(source_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        content += f"\n\n---\n*{status} at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n"
        
        with open(dest_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        # Remove original
        os.remove(source_path)
        
        return dest_path
        
    except Exception:
        return None


def request_approval(action_type: str, action_data: dict, timeout_minutes: int = DEFAULT_TIMEOUT_MINUTES,
                     wait: bool = True, verbose: bool = True) -> dict:
    """
    Request human approval for an action.
    
    Args:
        action_type: Type of action
        action_data: Action data
        timeout_minutes: Timeout in minutes
        wait: Wait for decision (blocking)
        verbose: Print status updates
    
    Returns:
        dict: Result with status and details
    """
    # Create request
    request_id, filepath = create_approval_request(action_type, action_data)
    
    result = {
        'request_id': request_id,
        'filepath': filepath,
        'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'status': 'PENDING'
    }
    
    if not wait:
        result['message'] = 'Approval request created. Use --check to monitor status.'
        return result
    
    # Wait for decision
    final_status = wait_for_approval(request_id, timeout_minutes, verbose=verbose)
    result['status'] = final_status
    
    if final_status == 'APPROVED':
        result['message'] = 'Action approved by human reviewer'
    elif final_status == 'REJECTED':
        result['message'] = 'Action rejected by human reviewer'
    else:
        result['message'] = f'Approval timeout after {timeout_minutes} minutes'
    
    result['completed_at'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    return result


def main():
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        description='Human-in-the-loop approval for sensitive actions',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
    python request_approval.py --action email --data '{"to":"user@example.com","subject":"Test"}'
    python request_approval.py --action linkedin --data '{"content":"Post text"}' --timeout 30
    python request_approval.py --request-id email_20260218_123456 --check
        '''
    )
    
    # New request
    parser.add_argument('--action', '-a', help='Action type (email/linkedin/file_operation)')
    parser.add_argument('--data', '-d', help='Action data as JSON string')
    parser.add_argument('--timeout', type=int, default=DEFAULT_TIMEOUT_MINUTES, help='Timeout in minutes')
    parser.add_argument('--no-wait', action='store_true', help='Create request without waiting')
    
    # Check existing
    parser.add_argument('--request-id', '-r', help='Request ID to check')
    parser.add_argument('--check', '-c', action='store_true', help='Check status and exit')
    
    # Output
    parser.add_argument('--json', action='store_true', help='Output as JSON')
    parser.add_argument('--quiet', '-q', action='store_true', help='Suppress status updates')
    
    args = parser.parse_args()
    
    # Check existing request
    if args.request_id and args.check:
        status, decided_at, comments = check_approval_status(args.request_id)
        result = {
            'request_id': args.request_id,
            'status': status,
            'decided_at': decided_at,
            'comments': comments
        }
        
        if args.json:
            print(json.dumps(result, indent=2))
        else:
            print(f"\nRequest: {args.request_id}")
            print(f"Status: {status}")
            if decided_at:
                print(f"Decided: {decided_at}")
            if comments:
                print(f"Comments: {comments}")
        
        sys.exit(0)
    
    # Wait for existing request
    if args.request_id and not args.action:
        status = wait_for_approval(args.request_id, args.timeout, verbose=not args.quiet)
        result = {
            'request_id': args.request_id,
            'status': status,
            'completed_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        
        if args.json:
            print(json.dumps(result, indent=2))
        else:
            print(f"\nResult: {status}")
        
        sys.exit(0 if status == 'APPROVED' else 1)
    
    # Create new request
    if not args.action:
        print("ERROR: --action is required")
        sys.exit(1)
    
    if not args.data:
        print("ERROR: --data is required (JSON string)")
        sys.exit(1)
    
    try:
        action_data = json.loads(args.data)
    except json.JSONDecodeError as e:
        print(f"ERROR: Invalid JSON in --data: {e}")
        sys.exit(1)
    
    result = request_approval(
        action_type=args.action,
        action_data=action_data,
        timeout_minutes=args.timeout,
        wait=not args.no_wait,
        verbose=not args.quiet
    )
    
    if args.json:
        print(json.dumps(result, indent=2))
    else:
        print(f"\n{'='*50}")
        print(f"Human Approval Result")
        print(f"{'='*50}")
        print(f"Request ID: {result['request_id']}")
        print(f"Status: {result['status']}")
        print(f"Message: {result.get('message', 'N/A')}")
        print(f"Created: {result['created_at']}")
        if result.get('completed_at'):
            print(f"Completed: {result['completed_at']}")
        print(f"{'='*50}\n")
    
    sys.exit(0 if result['status'] == 'APPROVED' else 1)


if __name__ == '__main__':
    main()
